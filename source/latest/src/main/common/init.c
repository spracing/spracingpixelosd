/*
 * Copyright 2019-2023 Dominic Clifton
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * SP Racing Pixel OSD by Dominic Clifton
 *
 * The SP Racing Pixel OSD system is a software and hardware implementation of a pixel based On-screen-display system.
 * It can detect and generate video sync signals and generate pixel signals on the video output signal.
 *
 * Depending on hardware implementation the incoming video can be disabled on a per-pixel basis, there are thus two modes.
 * Masked or Watermarked.  Masked pixels have consistent brightness, Watermarked pixels appear brighter or darker depending
 * on the background of the pixel.
 *
 * Various STM32 peripherals are used, and there non-obvious internal system interconnects to be aware of.
 * If you're modifying the source you *must* have a deep understanding of the interconnects used.  For instance hardware
 * pins, timers, timer channels, DMA streams, comparators, DAC channels, nvic priorities are not arbitrary.
 *
 * General system overview:
 *
 * Incoming video sync signal, at a non-fixed voltage, appears on the comparator input.
 * When the edge changes a timer is started, this timer is used to time the sync pulse at the next edge change
 * and to determine when to start the pixel generation.
 * The sync code monitors sync edge changes to determine frame and line position and also to trigger another timer
 * which is used for pixel generation.
 * Pixels are generated by feeding a bit-stream to 4 GPIO pins which control how the video signal is modified.
 * The sync handling code occurs around 31,000 times a second (15,000 * 2 edges), the exact frequency depends on the
 * video format (PAL/NTSC).
 * There is a second part to the system which attempts to figure out if there is a valid video signal being received,
 * and what the associated voltages are. Note that video voltage *may* drift as cameras warm up or cool down.
 * When no video signal is received a third sub-system is used to generate a video sync signal.  This generated
 * sync signal is then handled by the sync handling code exactly as if a camera was connected.
 *
 * Brightness level/pixel enable for individual pixels are stored in 2 full-screen framebuffers.  2 BPP.
 *
 * It is necessary to balance the requirements of other tasks against the resolution used by the OSD.  The
 * resolution is not fixed, but remember that the more pixels you want to draw the more operations you have to do
 * on the frame buffer, the longer it takes to clear it and also create and send the pixel streams via DMA.
 *
 * The system has to also deal with cameras that don't immediately generate video signals on power up as well as
 * external camera switching systems.
 *
 * Unlike other OSD implementations, the system does not use any SPI ports, the following internal peripherals are used:
 * 3 timers, 1 comparator, 2 DAC channels, 2 DMA streams (Sync generation, Pixel Generation), 6 GPIO pins.
 *
 * 2 Additional GPIO pins can be used for pin debugging, the best ones are the ones that are also outputs for the pixel
 * generation timer.  FC designers should note that the OSD system does not use the AF outputs of the pixel generation
 * timer so connecting status LEDs to those outputs is helpful for production targets if you need some pins for LEDs.
 *
 * Author: Dominic Clifton - Sync generation, Sync Detection, Video Overlay and first-cut of working OSD system.
 */

#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <math.h>

#include "platform.h"

#include "time.h"
#include "library/memory_init.h"

#if defined(BETAFLIGHT)
#include "common/printf.h"

#include "drivers/dma.h"
#include "drivers/dma_reqmap.h"
#include "drivers/nvic.h"
#include "drivers/time.h"

#include "drivers/display.h"

#include "pg/spracing_pixel_osd.h"
#include "pg/vcd.h"
#endif

#include "spracingpixelosd_impl.h"
#include "api/spracingpixelosd_api.h"

#include "configuration.h"
#include "framebuffer.h"
#include "pixelbuffer.h"
#include "pixelgeneration.h"
#include "videotiming.h"
#include "videoframe.h"
#include "syncdetection.h"
#include "syncgeneration.h"
#include "io.h"
#include "glue.h"
#include "utils.h"


// All 8 pins of the OSD GPIO port are reserved for OSD use if any are using GPIO OUTPUT MODE
// The 8 pins on the OSD GPIO port *can* be used for other functions, just not GPIO OUTPUT, e.g. mixing QUADSPI_BK2 and 4 GPIO pins on GPIOE on the H750 is fine.
// Note: using the BSRR register instead of ODR could also be implemented for greater IO flexibility.


//
// Output Specification
//

// 48us * 80mhz = 3840 clocks.  3840 clocks / 720 = 5.33 clocks per pixel.
// resolution scale of 2 = 10.77 clocks per pixel = 360 pixels.
// 5 * 720 = 3600 clocks / 80 = 45us.
// 6 * 720 = 4320 clocks / 80 = 54us == Too long!

// 48us * 100mhz = 4800 clocks.  4800 clocks / 720 = 6.6 clocks per pixel.
// resolution scale of 2 = 13.33 clocks per pixel = 360 pixels.
// 7 * 720 = 5040 clocks / 100 = 50.04us.
//#define CLOCKS_PER_PIXEL 6.6

// 48us * 120mhz = 5760 clocks.  5760 clocks / 720 = 8 clocks per pixel.
// resolution scale of 2 = 16 clocks per pixel = 360 pixels.
// 8 * 720 = 5760 clocks / 120 = 48.00us
//#define CLOCKS_PER_PIXEL 8

#define CLOCKS_PER_PIXEL(timerHz) ((float)(48.0f * ((float)timerHz / 1000000.0f)) / (float)HORIZONTAL_RESOLUTION)

//#define OVERLAY_LENGTH ((CLOCKS_PER_PIXEL * HORIZONTAL_RESOLUTION) / TIMER_CLOCKS_PER_US) // us

//
// State
//

volatile bool cameraConnected = true;
extern volatile uint8_t *committedFrameBuffer;

const spracingPixelOSDHostAPI_t *hostAPI = NULL;
spracingPixelOSDState_t spracingPixelOSDState;

void stateSetError(uint16_t errorCode)
{
    spracingPixelOSDState.errorCode = errorCode;
    spracingPixelOSDState.flags |= PIXELOSD_FLAG_ERROR;
}

bool stateErrorIsSet(void) {
    return (spracingPixelOSDState.flags & PIXELOSD_FLAG_ERROR) != 0;
}

//
// Sync Detection/Timing
//

TIM_HandleTypeDef htim1 = {0};
TIM_HandleTypeDef htim2 = {0};
TIM_HandleTypeDef htim15 = {0};
DMA_HandleTypeDef hdma_tim1_up = {0};
DMA_HandleTypeDef hdma_tim15_ch1 = {0};
COMP_HandleTypeDef hcompx = {0};
DAC_HandleTypeDef hdac1 = {0};
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;



//
// Init
//

static void avoidMCO1SyncClash(void)
{
    // See MCO1_GPIO_PORT & MCO1_PIN in stm32h7xx_hal_rcc.c & stm32l4xx_hal_rcc.c
#if defined(STM32H7) || defined(STM32L4)
    #define MCO1_GPIO_PORT        GPIOA
    #define MCO1_PIN              GPIO_PIN_8
#else
#  error MCU implementation required.
#endif


    if ((SPRACING_PIXEL_OSD_SYNC_OUT_Pin == MCO1_PIN) && (SPRACING_PIXEL_OSD_SYNC_OUT_GPIO_Port == MCO1_GPIO_PORT)) {
        // PA8 is MCO by default, which interferes with the comparator trigger
        GPIO_InitTypeDef GPIO_InitStruct = {0};

        HAL_GPIO_WritePin(SPRACING_PIXEL_OSD_SYNC_OUT_GPIO_Port, SPRACING_PIXEL_OSD_SYNC_OUT_Pin, GPIO_PIN_RESET);

        GPIO_InitStruct.Pin = SPRACING_PIXEL_OSD_SYNC_OUT_Pin;
        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
        HAL_GPIO_Init(SPRACING_PIXEL_OSD_SYNC_OUT_GPIO_Port, &GPIO_InitStruct);
    }
}

static void gpioEnable(GPIO_TypeDef *GPIOx)
{
    switch ((uint32_t)GPIOx) {
    case (uint32_t)GPIOA:
        __HAL_RCC_GPIOA_CLK_ENABLE();
        break;
    case (uint32_t)GPIOB:
        __HAL_RCC_GPIOB_CLK_ENABLE();
        break;
    case (uint32_t)GPIOC:
        __HAL_RCC_GPIOC_CLK_ENABLE();
        break;
#if defined(STM32H7)
    case (uint32_t)GPIOD:
        __HAL_RCC_GPIOD_CLK_ENABLE();
        break;
    case (uint32_t)GPIOE:
        __HAL_RCC_GPIOE_CLK_ENABLE();
        break;
#endif
    }
}

void HAL_MspInit(void)
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

#if defined(STM32L4)
  __HAL_RCC_SYSCFG_CLK_ENABLE(); // also enables COMP1/2, See RM0394 Rev 4 - "19.3.3 COMP reset and clocks"
  __HAL_RCC_PWR_CLK_ENABLE();
#endif

  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(htim->Instance==TIM1)
  {
  /* USER CODE BEGIN TIM1_MspPostInit 0 */

  /* USER CODE END TIM1_MspPostInit 0 */

      gpioEnable(SPRACING_PIXEL_OSD_SYNC_OUT_GPIO_Port);

      /**TIM1 GPIO Configuration
      PE12     ------> TIM1_CH3N
      OR
      PA8      ------> TIM1_CH1
      */
      GPIO_InitStruct.Pin = SPRACING_PIXEL_OSD_SYNC_OUT_Pin;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      if (!cameraConnected) {
          GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
          GPIO_InitStruct.Pull = GPIO_NOPULL;
          GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
      } else {
          GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
          GPIO_InitStruct.Pull = GPIO_NOPULL;
      }
      HAL_GPIO_Init(SPRACING_PIXEL_OSD_SYNC_OUT_GPIO_Port, &GPIO_InitStruct);


#ifdef DEBUG_GATING
      gpioEnable(SPRACING_PIXEL_OSD_SYNC_OUT_GPIO_Port);
      gpioEnable(SPRACING_PIXEL_OSD_GATING_DEBUG_GPIO_Port);
      GPIO_InitStruct.Pin = SPRACING_PIXEL_OSD_GATING_DEBUG_Pin;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_PULLDOWN;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      GPIO_InitStruct.Alternate = SPRACING_PIXEL_OSD_GATING_DEBUG_GPIO_AF;
      HAL_GPIO_Init(SPRACING_PIXEL_OSD_GATING_DEBUG_GPIO_Port, &GPIO_InitStruct);
#endif

#ifdef DEBUG_BLANKING
      gpioEnable(SPRACING_PIXEL_OSD_BLANKING_DEBUG_GPIO_Port);
      GPIO_InitStruct.Pin = SPRACING_PIXEL_OSD_BLANKING_DEBUG_Pin;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_PULLDOWN;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      GPIO_InitStruct.Alternate = SPRACING_PIXEL_OSD_BLANKING_DEBUG_GPIO_AF;
      HAL_GPIO_Init(SPRACING_PIXEL_OSD_BLANKING_DEBUG_GPIO_Port, &GPIO_InitStruct);
#endif

  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }
  else if(htim->Instance==TIM15)
  {
  /* USER CODE BEGIN TIM15_MspPostInit 0 */

  /* USER CODE END TIM15_MspPostInit 0 */

#ifdef DEBUG_PIXEL_TIMER
    gpioEnable(SPRACING_PIXEL_OSD_PIXEL_DEBUG_1_GPIO_Port);
    /**TIM15 GPIO Configuration
    PE5     ------> TIM15_CH1
    PE6     ------> TIM15_CH2
    */
    GPIO_InitStruct.Pin = SPRACING_PIXEL_OSD_PIXEL_DEBUG_1_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = SPRACING_PIXEL_OSD_PIXEL_DEBUG_1_GPIO_AF;
    HAL_GPIO_Init(SPRACING_PIXEL_OSD_PIXEL_DEBUG_1_GPIO_Port, &GPIO_InitStruct);
#endif
  /* USER CODE BEGIN TIM15_MspPostInit 1 */

  /* USER CODE END TIM15_MspPostInit 1 */
  }

}

void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
{
  if(htim->Instance==TIM2)
  {
    __HAL_RCC_TIM2_CLK_ENABLE();
  }
}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM1)
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();

    /* TIM1 DMA Init */
    /* TIM1_UP Init */
#if defined(STM32H7)
    hdma_tim1_up.Instance = DMA2_Stream6;
#elif defined(STM32L4)
    hdma_tim1_up.Instance = DMA1_Channel6; // TIM1_UP
#else
#  error MCU implementation required.
#endif
    HAL_DMA_DeInit(&hdma_tim1_up);

#if defined(STM32H7)
    hdma_tim1_up.Init.Request = DMA_REQUEST_TIM1_UP;
    hdma_tim1_up.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
#elif defined(STM32L4)
    hdma_tim1_up.Init.Request = DMA_REQUEST_7; // TIM1_UP
#else
#  error MCU implementation required.
#endif

    hdma_tim1_up.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_tim1_up.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_tim1_up.Init.MemInc = DMA_MINC_ENABLE;
    hdma_tim1_up.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_tim1_up.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_tim1_up.Init.Mode = DMA_CIRCULAR;
    hdma_tim1_up.Init.Priority = DMA_PRIORITY_HIGH;
    if (HAL_DMA_Init(&hdma_tim1_up) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(htim_base,hdma[TIM_DMA_ID_UPDATE],hdma_tim1_up);

    /* TIM1 interrupt Init */
    HAL_NVIC_SetPriority(TIM1_CC_IRQn, 2, 3);
    HAL_NVIC_EnableIRQ(TIM1_CC_IRQn);
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }
  else if(htim_base->Instance==TIM2)
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }

  else if(htim_base->Instance==TIM15)
  {
  /* USER CODE BEGIN TIM15_MspInit 0 */

  /* USER CODE END TIM15_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM15_CLK_ENABLE();

    /* TIM15 DMA Init */
    /* TIM15_CH1_UP_TRIG_COM Init */
#if defined(STM32H7)
    hdma_tim15_ch1.Instance = DMA2_Stream7;
    hdma_tim15_ch1.Init.Request = DMA_REQUEST_TIM15_CH1;
    hdma_tim15_ch1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
#elif defined(STM32L4)
    hdma_tim15_ch1.Instance = DMA1_Channel5; // TIM15_UP
    hdma_tim15_ch1.Init.Request = DMA_REQUEST_7; // TIM15_UP
#else
#  error MCU implementation required.
#endif

    hdma_tim15_ch1.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_tim15_ch1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_tim15_ch1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_tim15_ch1.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_tim15_ch1.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_tim15_ch1.Init.Mode = DMA_NORMAL;
    hdma_tim15_ch1.Init.Priority = DMA_PRIORITY_VERY_HIGH;
    if (HAL_DMA_Init(&hdma_tim15_ch1) != HAL_OK)
    {
      Error_Handler();
    }

    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(htim_base,hdma[TIM_DMA_ID_CC1],hdma_tim15_ch1);
//    __HAL_LINKDMA(htim_base,hdma[TIM_DMA_ID_UPDATE],hdma_tim15_ch1);
//    __HAL_LINKDMA(htim_base,hdma[TIM_DMA_ID_TRIGGER],hdma_tim15_ch1);
//    __HAL_LINKDMA(htim_base,hdma[TIM_DMA_ID_COMMUTATION],hdma_tim15_ch1);

  /* USER CODE BEGIN TIM15_MspInit 1 */

  /* USER CODE END TIM15_MspInit 1 */
  }
}


/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

    /* USER CODE BEGIN ADC1_Init 0 */

    /* USER CODE END ADC1_Init 0 */

    ADC_ChannelConfTypeDef sConfig = {0};

    /* USER CODE BEGIN ADC1_Init 1 */

    hadc1.Instance = ADC1;
    HAL_ADC_DeInit(&hadc1);

    /* USER CODE END ADC1_Init 1 */
    /** Common config
     */
    hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV12;
    hadc1.Init.Resolution = ADC_RESOLUTION_12B;
    hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
    hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
    hadc1.Init.LowPowerAutoWait = DISABLE;
    hadc1.Init.ContinuousConvMode = DISABLE;
    hadc1.Init.NbrOfConversion = 1;
    hadc1.Init.DiscontinuousConvMode = DISABLE;
    hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIG_T1_CC2;
    hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
    hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
    hadc1.Init.OversamplingMode = DISABLE;
#ifdef STM32H7
    hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
    hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
#endif

    if (HAL_ADC_Init(&hadc1) != HAL_OK)
    {
        Error_Handler();
    }
    /** Configure the ADC multi-mode
     */
#if 0 // This fails if ADC is already configured in FC code, FC code should not use anything other than ADC_MODE_INDEPENDENT.
    ADC_MultiModeTypeDef multimode = {0};

    multimode.Mode = ADC_MODE_INDEPENDENT;
    if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
    {
        Error_Handler();
    }
#endif
    /** Configure Regular Channel
     */
    sConfig.Channel = ADC_CHANNEL_8;
    sConfig.Rank = ADC_REGULAR_RANK_1;
#if defined(STM32H7)
    sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
#elif defined(STM32L4)
    sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLE_5;
#else
#  error MCU implementation required.
#endif
    sConfig.SingleDiff = ADC_SINGLE_ENDED;
    sConfig.OffsetNumber = ADC_OFFSET_NONE;
    sConfig.Offset = 0;
    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
    {
        Error_Handler();
    }
    /* USER CODE BEGIN ADC1_Init 2 */

    /* USER CODE END ADC1_Init 2 */

}
#if defined(BETAFLIGHT)

void SYNC_DMA_IRQHandler(dmaChannelDescriptor_t* descriptor)
{
    UNUSED(descriptor);
    //    HAL_DMA_IRQHandler(TimHandle.hdma[descriptor->userParam]);
    HAL_DMA_IRQHandler(&hdma_tim1_up);
}

void PIXEL_DMA_IRQHandler(dmaChannelDescriptor_t* descriptor)
{
    UNUSED(descriptor);
    //    HAL_DMA_IRQHandler(TimHandle.hdma[descriptor->userParam]);
    HAL_DMA_IRQHandler(&hdma_tim15_ch1);
}

#elif defined(FLIGHT_ONE)

void SYNC_DMA_IRQHandler(void)
{
    HAL_DMA_IRQHandler(&hdma_tim1_up);
}

void PIXEL_DMA_IRQHandler(void)
{
    HAL_DMA_IRQHandler(&hdma_tim15_ch1);
}
#else

void SYNC_DMA_IRQHandler(void)
{
    HAL_DMA_IRQHandler(&hdma_tim1_up);
}

void PIXEL_DMA_IRQHandler(void)
{
    HAL_DMA_IRQHandler(&hdma_tim15_ch1);
}

void ADC_DMA_IRQHandler(void)
{
    HAL_DMA_IRQHandler(&hdma_adc1);
}

#endif
static void MX_DMA_Init(void)
{
    /* DMA controller clock enable */
    __HAL_RCC_DMA1_CLK_ENABLE();
    __HAL_RCC_DMA2_CLK_ENABLE();

    // Sync Generation DMA
    //

#if defined(BETAFLIGHT)

    ioTag_t syncIoTag = timerioTagGetByUsage(TIM_USE_VIDEO_SYNC, 0);
    const timerHardware_t *syncTimerHardware = timerGetByTag(syncIoTag);

#if defined(USE_DMA_SPEC)
    const dmaChannelSpec_t *syncDmaSpec = dmaGetChannelSpecByTimer(syncTimerHardware);

    if (!syncDmaSpec) {
        return;
    }

    const dmaResource_t *syncDmaRef = syncDmaSpec->ref;
    uint32_t syncDmaChannel = syncDmaSpec->channel;
#else
    const dmaResource_t *syncDmaRef = syncTimerHardware->dmaRef;
    uint32_t syncDmaChannel = syncTimerHardware->dmaChannel;
#endif

    UNUSED(syncDmaChannel);

    uint16_t syncTimerChannel = syncTimerHardware->channel;
    uint16_t syncDmaIndex = timerDmaIndex(syncTimerChannel);

    dmaInit(dmaGetIdentifier(syncDmaRef), OWNER_OSD, 0);
    dmaSetHandler(dmaGetIdentifier(syncDmaRef), SYNC_DMA_IRQHandler, NVIC_PRIO_VIDEO_DMA, syncDmaIndex);

#elif defined(FLIGHT_ONE)
    HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 0, 3);
    HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
#else
#if defined(STM32H7)
    HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 0, 3);
    HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
#elif defined(STM32L4)
    // TIM1_UP = DMA1 Channel 6
    HAL_NVIC_SetPriority(DMA1_Channel6_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA1_Channel6_IRQn);
#else
#  error MCU implementation required.
#endif
#endif

    //
    // Pixel Generation DMA
    //

#if defined(BETAFLIGHT)

    ioTag_t pixelIoTag = timerioTagGetByUsage(TIM_USE_VIDEO_PIXEL, 0);
    const timerHardware_t *pixelTimerHardware = timerGetByTag(pixelIoTag);

#if defined(USE_DMA_SPEC)
    const dmaChannelSpec_t *pixelDmaSpec = dmaGetChannelSpecByTimer(pixelTimerHardware);

    if (!pixelDmaSpec) {
        return;
    }

    const dmaResource_t *pixelDmaRef = pixelDmaSpec->ref;
    uint32_t pixelDmaChannel = pixelDmaSpec->channel;
#else
    const dmaResource_t *pixelDmaRef = pixelTimerHardware->dmaRef;
    uint32_t pixelDmaChannel = pixelTimerHardware->dmaChannel;
#endif

    UNUSED(pixelDmaChannel);

    uint16_t pixelTimerChannel = pixelTimerHardware->channel;
    uint16_t pixelDmaIndex = timerDmaIndex(pixelTimerChannel);

    dmaInit(dmaGetIdentifier(pixelDmaRef), OWNER_OSD, 0);
    dmaSetHandler(dmaGetIdentifier(pixelDmaRef), PIXEL_DMA_IRQHandler, NVIC_PRIO_VIDEO_DMA, pixelDmaIndex);

#elif defined(FLIGHT_ONE)
    HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 3);
    HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);

    // TODO somehow enable the DMA code to use the callback handler PIXEL_DMA_IRQHandler
#else
#if defined(STM32H7)
    HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 3);
    HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);
#elif defined(STM32L4)
    // TIM15_UP = DMA1 Channel 5
    HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
#else
#  error MCU implementation required.
#endif

#endif
}

static void spracingPixelOSDSyncTriggerReset(void)
{

    TIM_SlaveConfigTypeDef sSlaveConfig = {0};

    if (cameraConnected) {
        // COMP2 trigger resets timer when camera connected
        sSlaveConfig.SlaveMode = TIM_SLAVEMODE_COMBINED_RESETTRIGGER;
        sSlaveConfig.InputTrigger = TIM_TS_ETRF;
    } else {
        sSlaveConfig.SlaveMode = TIM_SLAVEMODE_DISABLE;
        sSlaveConfig.InputTrigger = TIM_TS_ITR0;
    }

    sSlaveConfig.TriggerPolarity = TIM_TRIGGERPOLARITY_NONINVERTED;
    sSlaveConfig.TriggerPrescaler = TIM_TRIGGERPRESCALER_DIV1;
    sSlaveConfig.TriggerFilter = 0;
    if (HAL_TIM_SlaveConfigSynchronization(&htim1, &sSlaveConfig) != HAL_OK)
    {
      Error_Handler();
    }
}

void reconfigureVideoTimers(const videoTimings_t *vt)
{
    uint32_t syncTimerHz = getTimerHz(htim1.Instance);

    __HAL_TIM_SET_AUTORELOAD(&htim1, HZ_AND_NS_TO_CLOCKS(syncTimerHz, vt->lineNs) - 1);

    if (cameraConnected) { // avoid overwriting the SYNC capture compare register when sync generation is enabled since DMA will set it.

        // FIXME probably don't need to do this.
        __HAL_TIM_SET_COMPARE(&htim1, SYNC_TIMER_CHANNEL, HZ_AND_NS_TO_CLOCKS(syncTimerHz, vt->syncHSyncNs));
    }
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_4, HZ_AND_NS_TO_CLOCKS(syncTimerHz, (vt->syncHSyncNs + vt->backPorchNs) + (1000))); // start of picture data + offset
}

static void spracingPixelOSDSyncTimerInit(const videoTimings_t *vt)
{

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};

  /* USER CODE BEGIN TIM1_Init 1 */

  uint32_t timerBusClockHz = getTimerBusClockByInstance(TIM1);
  uint32_t timerHz = timerBusClockHz / 2; // See getTimerHz()
  uint8_t prescaler = (timerBusClockHz / timerHz) - 1;

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
  htim1.Init.Prescaler = prescaler;
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = HZ_AND_NS_TO_CLOCKS(timerHz, vt->lineNs) - 1;
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
/*
  // IMPORTANT: Start the timer BEFORE enabling slave mode.
  if (HAL_TIM_Base_Start(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  */

  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }

  if (HAL_TIM_OC_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }

  spracingPixelOSDSyncTriggerReset();

  // Channel 4 used to gate TIM15, TRGO2 unused, but can use it to trigger ADC of black level.
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC4REF;
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_ENABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }


  if (HAL_TIMEx_RemapConfig(&htim1, SPRACING_PIXEL_OSD_SYNC_TIM1_ETR_REMAP) != HAL_OK)
  {
    Error_Handler();
  }

  // ADC trigger channel
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = HZ_AND_NS_TO_CLOCKS(timerHz, 200); // always sample after a short delay.
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }

  // SYNC output channel
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = HZ_AND_NS_TO_CLOCKS(timerHz, vt->syncHSyncNs);
  sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_SET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, SYNC_TIMER_CHANNEL) != HAL_OK)
  {
    Error_Handler();
  }

  // GATING output channel
  sConfigOC.OCMode = TIM_OCMODE_PWM2;
  sConfigOC.Pulse = HZ_AND_NS_TO_CLOCKS(timerHz, (vt->syncHSyncNs + vt->backPorchNs) + (1000)); // start of picture data + offset
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_OC_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }

#ifdef DEBUG_GATING
#error DEBUG_GATING now clashes with ADC triggering, fix it.
  if (HAL_TIM_OC_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
#endif

  // Channel 5 used to blank comparator for duration of visible portion of line
  sConfigOC.OCMode = TIM_OCMODE_FORCED_ACTIVE;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_LOW;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_OC_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_5) != HAL_OK)
  {
    Error_Handler();
  }

#ifdef DEBUG_BLANKING
  if (HAL_TIM_OC_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
#endif



  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime = 0;
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  sBreakDeadTimeConfig.BreakFilter = 0;
  sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
  sBreakDeadTimeConfig.Break2Filter = 0;
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */
  HAL_TIM_MspPostInit(&htim1);

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_IC_InitTypeDef sConfigIC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  uint32_t timerBusClockHz = getTimerBusClockByInstance(TIM2);
  uint32_t timerHz = timerBusClockHz / 2; // See getTimerHz()
  uint8_t prescaler = (timerBusClockHz / timerHz) - 1;

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = prescaler;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 0xFFFF;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_IC_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_BOTHEDGE;
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
  sConfigIC.ICFilter = 0;
  if (HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
#if defined(STM32H7)
  if (HAL_TIMEx_TISelection(&htim2, TIM_TIM2_TI4_COMP2_OUT, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
#elif defined(STM32L4)
  if (HAL_TIMEx_RemapConfig(&htim2, TIM_TIM2_ITR1_USB_SOF|TIM_TIM2_TI4_COMP1) != HAL_OK)
  {
    Error_Handler();
  }
#else
#  error MCU implementation required.
#endif
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}

static void spracingPixelOsdPixelTimerInit(void)
{
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};

  __HAL_RCC_TIM15_CLK_ENABLE();

  uint32_t timerBusClockHz = getTimerBusClockByInstance(TIM15);
  //uint32_t timerHz = timerBusClockHz / 2; // See getTimerHz()
  uint32_t timerHz = timerBusClockHz; // See getTimerHz()
  uint8_t prescaler = (timerBusClockHz / timerHz) - 1;

  htim15.Instance = TIM15;
  htim15.Init.Prescaler = prescaler;
  htim15.Init.CounterMode = TIM_COUNTERMODE_UP;

#if defined(STM32H7)
  htim15.Init.Period = lrintf((float)CLOCKS_PER_PIXEL(timerHz) * (float)RESOLUTION_SCALE);
#elif defined(STM32L4)
  // FUTURE verify the code below works on H7 too, the H7 code was out-by-on on the L4 due to lrintf
  //        rounding 10.77 to 11. prototype code used a value of 10 which also works here for an 80Mhz timer clock.
  //        if the above code works everywhere then delete H7 version above and use this everywhere.
  htim15.Init.Period = (uint16_t)((float)CLOCKS_PER_PIXEL(timerHz) * (float)RESOLUTION_SCALE);
#else
#  error MCU implementation required.
#endif
  htim15.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim15.Init.RepetitionCounter = 0;
  htim15.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim15) != HAL_OK)
  {
    Error_Handler();
  }

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim15, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim15) != HAL_OK)
  {
    Error_Handler();
  }
  sSlaveConfig.SlaveMode = TIM_SLAVEMODE_GATED;
  sSlaveConfig.InputTrigger = TIM_TS_ITR0;
  if (HAL_TIM_SlaveConfigSynchronization(&htim15, &sSlaveConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim15, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = ((CLOCKS_PER_PIXEL(timerHz) / 2) * RESOLUTION_SCALE);
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_PWM_ConfigChannel(&htim15, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
{
    Error_Handler();
  }
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime = 0;
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim15, &sBreakDeadTimeConfig) != HAL_OK)
  {
    Error_Handler();
  }

  HAL_TIM_MspPostInit(&htim15);
}

//
// Sync Detection/Timing
//

void HAL_COMP_MspInit(COMP_HandleTypeDef* hcomp)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hcomp->Instance==SPRACING_PIXEL_OSD_SYNC_IN_COMP)
  {
  /* USER CODE BEGIN COMP2_MspInit 0 */

  /* USER CODE END COMP2_MspInit 0 */
    /* Peripheral clock enable */
#if defined(STM32H7)
    __HAL_RCC_COMP12_CLK_ENABLE();
#elif defined(STM32L4)
    // no-op
    // See HAL_MspInit and RCC_APB22ENR/SYSCFGEN which also enables the COMP.
    // See RM0394 Rev 4 - "19.3.3 COMP reset and clocks"
#else
#  error MCU implementation required.
#endif

    gpioEnable(SPRACING_PIXEL_OSD_SYNC_IN_GPIO_Port);
    GPIO_InitStruct.Pin = SPRACING_PIXEL_OSD_SYNC_IN_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(SPRACING_PIXEL_OSD_SYNC_IN_GPIO_Port, &GPIO_InitStruct);

    /* COMPx interrupt Init */
#if defined(BETAFLIGHT) || defined(FLIGHT_ONE)
    HAL_NVIC_SetPriority(COMP_IRQn, 0, 2);
#else
    // NO-OP
#endif

    HAL_NVIC_EnableIRQ(COMP_IRQn);
  /* USER CODE BEGIN COMP2_MspInit 1 */

  /* USER CODE END COMP2_MspInit 1 */
  }
}

void MX_COMPx_Init(void)
{
  hcompx.Instance = SPRACING_PIXEL_OSD_SYNC_IN_COMP;
  hcompx.Init.InvertingInput = COMP_INPUT_MINUS_DAC1_CH2;

  hcompx.Init.NonInvertingInput = SPRACING_PIXEL_OSD_SYNC_IN_COMP_INPUT;
  hcompx.Init.OutputPol = COMP_OUTPUTPOL_INVERTED;
  hcompx.Init.Hysteresis = COMP_HYSTERESIS_LOW; // LOW = more transitions near threshold, HIGH = fewer transitions near threshold,  H7: LOW=10mV, MEDIUM=20mV, HIGH=30mV
  //hcomp.Init.BlankingSrce = COMP_BLANKINGSRC_NONE; // during pixel output this this will be COMP_BLANKINGSRC_TIM1_OC5.
#if defined(STM32H7)
  hcompx.Init.BlankingSrce = COMP_BLANKINGSRC_TIM1_OC5;
#elif defined(STM32L4)
  hcompx.Init.BlankingSrce = COMP_BLANKINGSRCE_TIM1OC5;
#else
#  error MCU implementation required.
#endif
  hcompx.Init.Mode = COMP_POWERMODE_HIGHSPEED;
  hcompx.Init.WindowMode = COMP_WINDOWMODE_DISABLE;
  hcompx.Init.TriggerMode = COMP_TRIGGERMODE_IT_RISING_FALLING;
  if (HAL_COMP_Init(&hcompx) != HAL_OK)
  {
    Error_Handler();
  }
}

static uint32_t HAL_RCC_ADC12_CLK_ENABLED=0;

/**
* @brief ADC MSP Initialization
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hadc->Instance==ADC1)
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    HAL_RCC_ADC12_CLK_ENABLED++;
    if(HAL_RCC_ADC12_CLK_ENABLED==1){
#if defined(STM32H7)
        __HAL_RCC_ADC12_CLK_ENABLE();
#elif defined(STM32L4)
        __HAL_RCC_ADC_CLK_ENABLE();
#else
#  error MCU implementation required.
#endif
    }

    gpioEnable(SPRACING_PIXEL_OSD_VIDEO_IN_GPIO_Port);

    GPIO_InitStruct.Pin = SPRACING_PIXEL_OSD_VIDEO_IN_ADC_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(SPRACING_PIXEL_OSD_VIDEO_IN_GPIO_Port, &GPIO_InitStruct);

#if defined(SPRACING_PIXEL_OSD_VIDEO_OUT_ADC_Pin)
    gpioEnable(SPRACING_PIXEL_OSD_VIDEO_OUT_GPIO_Port);
    GPIO_InitStruct.Pin = SPRACING_PIXEL_OSD_VIDEO_OUT_ADC_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(SPRACING_PIXEL_OSD_VIDEO_OUT_GPIO_Port, &GPIO_InitStruct);
#endif


    /* ADC1 DMA Init */
    /* ADC1 Init */
#if defined(STM32H7)
    hdma_adc1.Instance = DMA2_Stream5;
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
#elif defined(STM32L4)
    // DMA2 Channel 3 = ADC1
    hdma_adc1.Instance = DMA2_Channel3;
    hdma_adc1.Init.Request = DMA_REQUEST_3;
#else
#  error MCU implementation required.
#endif

    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(hadc, DMA_Handle, hdma_adc1);

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}


/**
* @brief DAC MSP Initialization
* This function configures the hardware resources used in this example
* @param hdac: DAC handle pointer
* @retval None
*/
void HAL_DAC_MspInit(DAC_HandleTypeDef* hdac)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hdac->Instance==DAC1)
  {
  /* USER CODE BEGIN DAC1_MspInit 0 */

  /* USER CODE END DAC1_MspInit 0 */
    /* Peripheral clock enable */
#if defined(STM32H7)
    __HAL_RCC_DAC12_CLK_ENABLE();
#elif defined(STM32L4)
    __HAL_RCC_DAC1_CLK_ENABLE();
#else
#  error MCU implementation required.
#endif

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**DAC1 GPIO Configuration
    PA5     ------> DAC1_OUT2
    PA4     ------> DAC1_OUT1
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* USER CODE BEGIN DAC1_MspInit 1 */

  /* USER CODE END DAC1_MspInit 1 */
  }

}

static void MX_DAC1_Init(void)
{
  DAC_ChannelConfTypeDef sConfig = {0};

  /** DAC Initialization
  */
  hdac1.Instance = DAC1;
  if (HAL_DAC_Init(&hdac1) != HAL_OK)
  {
    Error_Handler();
  }
  /** DAC channel OUT1/2 config
  */
  sConfig.DAC_SampleAndHold = DAC_SAMPLEANDHOLD_DISABLE;
  sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
  sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
  sConfig.DAC_ConnectOnChipPeripheral = DAC_CHIPCONNECT_ENABLE;
  sConfig.DAC_UserTrimming = DAC_TRIMMING_FACTORY;
  if (HAL_DAC_ConfigChannel(&hdac1, &sConfig, DAC_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  sConfig.DAC_SampleAndHold = DAC_SAMPLEANDHOLD_DISABLE;
  sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
  sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
  sConfig.DAC_ConnectOnChipPeripheral = DAC_CHIPCONNECT_DISABLE;
  sConfig.DAC_UserTrimming = DAC_TRIMMING_FACTORY;
  if (HAL_DAC_ConfigChannel(&hdac1, &sConfig, DAC_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
}

void setVideoSourceVoltageMv(uint32_t whiteMv)
{
    // TODO get measured VREF via ADC and use instead of VIDEO_DAC_VCC here?
    uint32_t dacWhiteRaw = (whiteMv * 0x0FFF) / (VIDEO_DAC_VCC * 1000);

    HAL_DAC_SetValue(&hdac1, DAC_CHANNEL_1, DAC_ALIGN_12B_R, dacWhiteRaw);
}

//
// Video ADC
//

LIBRARY_D1_RAM volatile uint16_t videoInADCSamples[1] = {0};

DMA_HandleTypeDef *hVideoADCDMA;

uint32_t videoADC = 0;

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
#ifdef DEBUG_VIDEO_ADC
    pixelDebug1Toggle();
#endif

    videoADC = videoInADCSamples[0];

#ifdef DEBUG_VIDEO_ADC
    pixelDebug1Toggle();
#endif
}

void videoADCStart(void)
{
    if (HAL_ADC_Start_DMA(&hadc1,(uint32_t*) &videoInADCSamples, ARRAYLEN(videoInADCSamples)) != HAL_OK) {
        Error_Handler();
    }
}

void videoADCStop(void)
{
    if (hVideoADCDMA->State == HAL_DMA_STATE_BUSY) {
        if (HAL_ADC_Stop_DMA(&hadc1) != HAL_OK) {
            Error_Handler();
        }
    }
}
//
// Init
//

static bool spracingPixelOSDInitialised = false;

#ifdef BETAFLIGHT
// FIXME delete this when the BF code uses the API
bool spracingPixelOSDIsInitialised(void)
{
    return spracingPixelOSDInitialised;
}
#endif

struct vcdProfile_s;
struct spracingPixelOSDConfig_s;

bool spracingPixelOSDInitPrivate(const spracingPixelOSDDefaultConfig_t *defaultConfig)
{
    spracingPixelOSD_initIO();

    //
    // Timing
    //

    videoSystem_t videoSystem = VIDEO_SYSTEM_NTSC;

    if (defaultConfig->flags & PIXELOSD_CF_VIDEO_SYSTEM_PAL) {
      videoSystem = VIDEO_SYSTEM_PAL;
    }

    uint32_t syncTimerHz = getTimerHz(TIM1);

    refreshVideoTimings(syncTimerHz, videoSystem);
    configureSyncGeneration(syncTimerHz, videoSystem);
    recalculateBlankingTimings(videoTimings);

    //
    // Frame
    //

#ifdef FRAMEBUFFER_ERASE
    frameBuffer_eraseInit();
#endif

    uint8_t *fb0 = frameBuffer_getBuffer(0);
    uint8_t *fb1 = frameBuffer_getBuffer(1);

    outputFrameBuffer = fb0;

#ifdef FRAMEBUFFER_ERASE
    frameBuffer_erase(fb0);
    frameBuffer_erase(fb1);
#else
    UNUSED(fb1);
#endif

    //
    // Sync detection
    //

    avoidMCO1SyncClash();

    MX_COMPx_Init();
    MX_DAC1_Init();

    MX_TIM2_Init();


    // DAC CH2 - Generate comparator reference voltage

    setComparatorTargetMv(0);
    HAL_DAC_Start(&hdac1, DAC_CHANNEL_2);

    // DAC CH1 - White voltage

    setVideoSourceVoltageMv(2500);
    HAL_DAC_Start(&hdac1, DAC_CHANNEL_1);



    if (HAL_TIM_IC_Start(&htim2, TIM_CHANNEL_4) != HAL_OK)
    {
      Error_Handler();
    }

    //
    // Sync generation
    //

    MX_DMA_Init();

    spracingPixelOSDSyncTimerInit(videoTimings); // TIM1

    syncInit();

    //
    // Video ADC
    //

#if defined(BETAFLIGHT)
#error Video ADC DMA init not implemented in BETAFLIGHT, yet.
#elif defined(FLIGHT_ONE)
    HAL_NVIC_SetPriority(DMA2_Stream5_IRQn, 2, 0);
    HAL_NVIC_EnableIRQ(DMA2_Stream5_IRQn);
#else
#if defined(STM32H7)
    HAL_NVIC_SetPriority(DMA2_Stream5_IRQn, 2, 0);
    HAL_NVIC_EnableIRQ(DMA2_Stream5_IRQn);
#elif defined(STM32L4)
    // DMA2 Channel 3 = ADC1
    HAL_NVIC_SetPriority(DMA2_Channel3_IRQn, 2, 0);
    HAL_NVIC_EnableIRQ(DMA2_Channel3_IRQn);
#else
#  error MCU implementation required.
#endif
#endif

    MX_ADC1_Init();

    hVideoADCDMA = hadc1.DMA_Handle;

    videoADCStart();


    //
    // Pixel generation
    //

    spracingPixelOsdPixelTimerInit(); // TIM15

#ifdef DEBUG
    extern uint8_t pixelBufferA[];
    extern uint8_t pixelBufferB[];

    pixelBuffer_createTestPattern1(pixelBufferA, 16);
    pixelBuffer_createTestPattern1(pixelBufferB, 8);
#endif

    pixelInit();

    pixelGateAndBlankStart(); // Requires that TIM1 is initialised.

    // IRQ handler requires that timers are initialised.
    if(HAL_COMP_Start_IT(&hcompx) != HAL_OK)
    {
      Error_Handler();
    }

    spracingPixelOSDInitialised = true;

    return true;
}

void spracingPixelOSDPause(void)
{
    // Note: This doesn't stop everything, e.g. comparator and all timers

    if (!cameraConnected) {
        syncStopDMA();
        syncStopPWM();
    }

    pixelStopDMA();
    disableComparatorBlanking();
}

void spracingPixelOSDRestart(void)
{
  __HAL_TIM_DISABLE(&htim1);

    setComparatorTargetMv(0);
    videoFrame_reset();
    syncDetection_reset();

    spracingPixelOSDSyncTimerInit(videoTimings);

    syncInit();

    pixelGateAndBlankStart();
}

void configureMPU(void)
{
    HAL_MPU_Disable();

#if defined(STM32H7)
    // Ensure DMA ram is configured, e.g.
    // DMA transmit buffer in D2 SRAM1
    // Reading needs cache coherence operation
    extern uint8_t __library_dma_ram_start;
    extern uint8_t __library_dma_ram_end;


    MPU_Region_InitTypeDef MPU_InitStruct;

    MPU_InitStruct.Enable           = MPU_REGION_ENABLE;
    MPU_InitStruct.SubRegionDisable = 0x00;
    MPU_InitStruct.TypeExtField     = MPU_TEX_LEVEL0;

    MPU_InitStruct.Number           = MPU_REGION_NUMBER8; // TODO dynamically calculate this

    uint32_t start = (uint32_t)&__library_dma_ram_start;
    uint32_t length = (uint32_t)&__library_dma_ram_end - start;

    MPU_InitStruct.BaseAddress      = start;
    MPU_InitStruct.Size             = MPU_REGION_SIZE_64KB; // TODO dynamically calculate this from length

    // TODO ensure there is no overlap with existing MPUs regions.

    MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
    MPU_InitStruct.DisableExec      = MPU_INSTRUCTION_ACCESS_ENABLE;
    MPU_InitStruct.IsShareable      = MPU_ACCESS_SHAREABLE;
    MPU_InitStruct.IsCacheable      = MPU_ACCESS_CACHEABLE;
    MPU_InitStruct.IsBufferable     = MPU_ACCESS_NOT_BUFFERABLE;

    HAL_MPU_ConfigRegion(&MPU_InitStruct);

    // TODO if size is less than a region size then the remaining memory area in the region must be reserved
    // probably the solution is to ensure that the memory area used by the OSD code is determined by the length
    // of multiple regions, e.g.
    // something like: MPU_REGION_SIZE_32KB + MPU_REGION_SIZE_16KB + MPU_REGION_SIZE_4KB = 52K
    // framebuffers are 51,840 bytes, + pixel buffers, + etc.
#elif defined(STM32L4)
    // no cache = no-op!
#else
#  error MCU implementation required.
#endif
}

uint32_t calculateTimerBusClock(TIM_TypeDef *tim)
{

#if defined(STM32H7)
    int timpre;
    uint32_t pclk;
    uint32_t ppre;

    // Implement the table:
    // RM0433 Rev 6 "Table 52. Ratio between clock timer and pclk"

    if (tim == TIM1 || tim == TIM8 || tim == TIM15 || tim == TIM16 || tim == TIM17) {
        // Timers on APB2
        pclk = HAL_RCC_GetPCLK2Freq();
        ppre = (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2) >> RCC_D2CFGR_D2PPRE2_Pos;
    } else {
        // Timers on APB1
        pclk = HAL_RCC_GetPCLK1Freq();
        ppre = (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos;
    }

    timpre = (RCC->CFGR & RCC_CFGR_TIMPRE) ? 1 : 0;

    int index = (timpre << 3) | ppre;

    static uint8_t periphToKernel[16] = { // The mutiplier table
        1, 1, 1, 1, 2, 2, 2, 2, // TIMPRE = 0
        1, 1, 1, 1, 2, 4, 4, 4  // TIMPRE = 1
    };

    return pclk * periphToKernel[index];
#elif defined(STM32L4)
    // FUTURE could be improved by checking RCC AHB_PRESC, and RCC APB1/2_PRESC
    //        they're currently all 1 and the CPU speed is 80Mhz, so all timers have the same bus clock as the CPU core.
    if (tim == TIM1 || tim == TIM15 || tim == TIM16) {
        // Timers on APB2
        return 80000000;
    } else {
        // Timers on APB1
        return 80000000;
    }
#else
#  error MCU implementation required.
#endif
}

typedef struct timerMapping_s {
    timerId_e id;
    TIM_TypeDef *instance;
} timerMapping_t;

static const timerMapping_t timerMappings[USED_TIMER_COUNT] = {
    { TIMER_TIM1, TIM1 },
    { TIMER_TIM2, TIM2 },
    { TIMER_TIM15, TIM15 }
};

uint32_t timerBusClocks[USED_TIMER_COUNT]; // stored in same order as timerMappings entries.

uint32_t getTimerBusClockById(timerId_e id)
{
    for (int index = 0; index < USED_TIMER_COUNT; index++) {
        const timerMapping_t *mapping = &timerMappings[index];
        if (mapping->id == id) {
            return timerBusClocks[index];
        }
    }
    return 0;
}

uint32_t getTimerBusClockByInstance(TIM_TypeDef *instance)
{
    for (int index = 0; index < USED_TIMER_COUNT; index++) {
        const timerMapping_t *mapping = &timerMappings[index];
        if (mapping->instance == instance) {
            return timerBusClocks[index];
        }
    }
    return 0;
}

static void updateTimerBusClocks(void)
{
    for (int index = 0; index < USED_TIMER_COUNT; index++) {
        const timerMapping_t *mapping = &timerMappings[index];
        timerBusClocks[index] = calculateTimerBusClock(mapping->instance);
    }
}

static bool verifyTimerBusClocks(void)
{
    uint32_t tim1BusClk = getTimerBusClockByInstance(TIM1);
    uint32_t tim2BusClk = getTimerBusClockByInstance(TIM2);
    uint32_t tim15BusClk = getTimerBusClockByInstance(TIM15);

#if defined(STM32H7)
    if ((tim1BusClk == 200000000) && (tim2BusClk == 200000000) && (tim15BusClk == 200000000)) {
        return true;
    }
    if ((tim1BusClk == 240000000) && (tim2BusClk == 240000000) && (tim15BusClk == 240000000)) {
        return true;
    }

    if ((tim1BusClk == 260000000) && (tim2BusClk == 260000000) && (tim15BusClk == 260000000)) {
        return true;
    }
#elif defined(STM32L4)
    if ((tim1BusClk == 80000000) && (tim2BusClk == 80000000) && (tim15BusClk == 80000000)) {
        return true;
    }
#else
#  error MCU implementation required.
#endif

    stateSetError(PIXELOSD_EC_UNSUPPORTED_TIMER_BUS_CLK);
    return false;
}

uint32_t getTimerHz(TIM_TypeDef *instance)
{
    // WARNING: all used timers are initialised at half of the timer bus clock speed, update this if the situation changes.
    return getTimerBusClockByInstance(instance) / 2;
}

//
// API
//

void spracingPixelOSDInit(const spracingPixelOSDHostAPI_t *hostAPIFromClient, const spracingPixelOSDDefaultConfig_t *defaultConfig)
{
    memoryInit();
    SystemCoreClockUpdate();
    //configureMPU();

    updateTimerBusClocks();

    if (!verifyTimerBusClocks()) {
        return;
    }


    hostAPI = hostAPIFromClient;

    memset(&spracingPixelOSDState, 0, sizeof(spracingPixelOSDState));

    bool result = spracingPixelOSDInitPrivate(defaultConfig);

    if (result) {
      spracingPixelOSDState.flags |= PIXELOSD_FLAG_INITIALISED;
    } else {
      spracingPixelOSDState.flags |= PIXELOSD_FLAG_ERROR;
    }

}

void spracingPixelFrameBufferCommit(uint8_t *frameBuffer)
{
  committedFrameBuffer = frameBuffer;
}

spracingPixelOSDState_t *spracingPixelOSDGetState(void)
{
    return &spracingPixelOSDState;
}

